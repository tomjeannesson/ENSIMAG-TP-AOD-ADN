\documentclass[10pt,a4paper]{article}

% \usepackage[latin1]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{enumerate}

%%%% POUR FAIRE TENIR SUR UNE PAGE RECTO-VERSO.....
\textwidth 18.5cm
\oddsidemargin -1.75cm
\evensidemargin -1.75cm
\textheight 28.0cm
\topmargin -3.0cm

%   \textwidth 18cm
   %\oddsidemargin -1.5cm
   %\evensidemargin -1.5cm
   %\textheight 26.0cm
   %\topmargin -2.0cm
 


\begin{document}

\thispagestyle{empty}

\noindent\centerline{\bf\large Questionnaire  TP AOD 2023-2024 ? compl?ter et rendre sur teide  } \\
Bin?me 
(NOM\textsubscript{1} Pr?nom\textsubscript{1} --
 NOM\textsubscript{2} Pr?nom\textsubscript{2})
\,: \dotfill

\section{Pr?ambule 1 point}.
Le programme r?cursif avec m?moisation fourni alloue une m?moire de taille $N.M$.
Il g?n?re une erreur d'ex?cution sur le test 5 (c-dessous) . Pourquoi ? \\
R?ponse:  A COMPLETER 
\begin{verbatim}
distanceEdition-recmemo    GCA_024498555.1_ASM2449855v1_genomic.fna 77328790 20236404   \
                           GCF_000001735.4_TAIR10.1_genomic.fna 30808129 19944517 
\end{verbatim}

%%%%%%%%%%%%%%%%%%%
{\noindent\bf{Important}.} Dans toute la suite, on demande des programmes qui allouent un espace m?moire $O(N+M)$.

\section{Programme it?ratif en espace m?moire $O(N+M)$ (5 points)}
{\em Expliquer tr?s bri?vement (2 ? 5 lignes max) le principe de votre code, la m?moire utilis?e, le sens de parcours des tableaux.}
\vspace*{1.0cm}

Analyse du co?t th?orique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ 
\begin{enumerate}
  \item place m?moire allou?e (ne pas compter les 2 s?quences $X$ et $Y$ en m?moire via {\tt mmap}) : 
  \item travail (nombre d'op?rations) : 
  \item nombre de d?fauts de cache obligatoires (sur mod?le CO, y compris sur $X$ et $Y$):
  \item nombre de d?fauts de cache si $Z \ll \min(N,M)$ : 
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache aware  (3 points)}
{\em Expliquer tr?s bri?vement (2 ? 5 lignes max) le principe de votre code, la m?moire utilis?e, le sens de parcours des tableaux.}
\vspace*{1.0cm}

Analyse du co?t th?orique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item place m?moire (ne pas compter les 2 s?quences initiales $X$ et $Y$ en m?moire via {\tt mmap}) : 
  \item travail (nombre d'op?rations) : 
  \item nombre de d?fauts de cache obligatoires (sur mod?le CO, y compris sur $X$ et $Y$):
  \item nombre de d?fauts de cache si $Z \ll \min(N,M)$ : 
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache oblivious  (3 points)}
{\em Expliquer tr?s bri?vement (2 ? 5 lignes max) le principe de votre code, la m?moire utilis?e, le sens de parcours des tableaux.}
\vspace*{1.0cm}

Analyse du co?t th?orique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item place m?moire (ne pas compter les 2 s?quences initiales $X$ et $Y$ en m?moire via {\tt mmap}) : 
  \item travail (nombre d'op?rations) : 
  \item nombre de d?fauts de cache obligatoires (sur mod?le CO, y compris sur $X$ et $Y$):
  \item nombre de d?fauts de cache si $Z \ll \min(N,M)$ : 
\end{enumerate}

\section{R?glage du seuil d'arr?t r?cursif du programme cache oblivious  (1 point)} 
Comment faites-vous sur une machine donn?e pour choisir ce seuil d'arr?t? Quelle valeur avez vous choisi pour les
PC de l'Ensimag? (2 ? 3 lignes) 

%%%%%%%%%%%%%%%%%%%
\section{Exp?rimentation (7 points)}

Description de la machine d'exp?rimentation:  \\
Processeur: A PRECISER  --
M?moire: A PRECISER --
Syst?me: A PRECISER 

\subsection{(3 points) Avec {\tt 
	valgrind --tool =cachegrind --D1=4096,4,64
}} 
\begin{verbatim}
     distanceEdition ba52_recent_omicron.fasta 153 N wuhan_hu_1.fasta 116 M 
\end{verbatim}
en prenant pour $N$ et $M$ les valeurs dans le tableau ci-dessous.


Les param?tres du cache LL de second niveau est : ...
{\em mettre ici les param?tres: soit ceux indiqu?s ligne 3
du fichier cachegrind.out.(pid) g?n?r? par valgrind: soit ceux par d?faut,
soit ceux que vous avez sp?cifi?s ? la main
\footnote{par exemple:
{\tt valgrind --tool=cachegrind --D1=4096,4,64 --LL=65536,16,256  ... }
mais ce n'est pas demand? car cela allonge le temps de simulation. } 
 pour LL. }

{\em Le tableau ci-dessous est un exemple,  compl?t? avec vos r?sultats et 
ensuite analys?.}
\\
{\footnotesize
\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{r?cursif m?mo}
& \multicolumn{3}{c||}{it?ratif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& \#Irefs & \#Drefs & \#D1miss % recursif memoisation
& \#Irefs & \#Drefs & \#D1miss % it?ratif
& \#Irefs & \#Drefs & \#D1miss % cache aware
& \#Irefs & \#Drefs & \#D1miss % cache oblivious
\\ \hline
\hline
1000 & 1000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
1000 & 1000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
2000 & 1000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
4000 & 1000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
2000 & 2000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
4000 & 4000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
6000 & 6000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
8000 & 8000 
&  &  &   % recursif memoisation
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
\hline
\end{tabular}
}

\paragraph{Important: analyse exp?rimentale:} 
ces mesures exp?rimentales sont elles en accord avec les co?ts analys?s th?roiquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les param?tres propos?s, pourquoi ?


\subsection{(3 points) Sans valgrind, par ex?cution de la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & M \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & N
\end{tabular}}

On mesure le temps ?coul?, le temps CPU et l'?nergie consomm?e avec : {\em  [pr?sicer ici comment vous avez fait la mesure:
{\tt time} 
ou {\tt /usr/bin/time}
ou {\tt getimeofday}
ou {\tt getrusage}
% ou {\tt perfstart/perfstop\_and\_display}%
% \footnote{
%     cf {\tt /matieres/4MMAOD6/2023-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf/0-LisezMoi}
% }
ou... \\
L'?nergie consomm?e sur le processeur peut ?tre estim?e en regardant le compteur RAPL d'?nergie (en microJoule)
pour chaque core avant et apr?s l'ex?cution et en faisant la diff?rence.
Le compteur du core $K$ est dans le fichier 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:K/energy_uj + .\\
Par exemple, pour le c{\oe}ur 0: 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj +
% Les fonctions fournies 
% {\tt perfstart/perfstop\_and\_display} dans le r?pertoire
% {\tt /matieres/4MMAOD6/2022-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf} 
% font ces mesures de temps cpu, ecoul? et ?nergie.
% }

Nota bene: pour avoir un r?sultat fiable/reproductible (si variailit?), 
il est pr?f?rable de faire chaque mesure 5 fois et de reporter l'intervalle
de confiance [min, moyenne, max]. 

\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{it?ratif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& temps   & temps & energie       % it?ratif
& temps   & temps & energie       % cache aware
& temps   & temps & energie       % cache oblivious
\\
& 
& cpu     & ?coul?&               % it?ratif
& cpu     & ?coul?&               % cache aware
& cpu     & ?coul?&               % cache oblivious
\\ \hline
\hline
10000 & 10000 
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
20000 & 20000 
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
30000 & 30000 
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
40000 & 40000 
&  &  &   % it?ratif
&  &  &   % cache aware
&  &  &   % cache oblivious
\\ \hline
\hline
\end{tabular}
\paragraph{Important: analyse exp?rimentale:} 
ces mesures exp?rimentales sont elles en accord avec les co?ts analys?s th?roiquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les param?tres propos?s, pourquoi ?

\subsection{(1 point) Extrapolation: estimation de la dur?e et de l'?nergie pour la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & 20236404  \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & 19944517 
\end{tabular}
}

A partir des r?sultats pr?c?dents, le programme {\em pr?ciser it?ratif/cache aware/ cache oblivious}?est
le plus performant pour la commande ci dessus (test 5); les ressources pour l'ex?cution seraient environ:
{\em (pr?ciser la m?thode de calcul utilis?e)} 
\begin{itemize}
\item Temps cpu (en s) : ...
\item Energie  (en kWh) : ... .
\end{itemize}
Question subsidiaire: comment feriez-vous pour avoir un programme s'ex?cutant en moins de 1 minute ? 
{\em donner le principe en moins d'une ligne, m?me 1 mot pr?cis suffit! }


\end{document}
